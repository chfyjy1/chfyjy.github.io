<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qtaxserver.qdoc -->
  <title>Building ActiveX servers in Qt | Active Qt 5.9</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    window.onload = function(){document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");};
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/supported-platforms-and-configurations.html#qt-5-9">Qt 5.9</a></td><td ><a href="activeqt-index.html">Active Qt</a></td><td >在Qt中构建ActiveX服务器</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt 5.9.0 手册</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#using-the-library">库的使用</a></li>
<li class="level2"><a href="#out-of-process-vs-in-process">跨进程与进程内</a></li>
<li class="level2"><a href="#typical-errors-during-the-post-build-steps">Post-Build步骤中的典型错误</a></li>
<li class="level1"><a href="#implementing-controls">控件实现</a></li>
<li class="level2"><a href="#data-types">数据类型</a></li>
<li class="level2"><a href="#sub-objects">子对象</a></li>
<li class="level2"><a href="#property-notification">属性通知</a></li>
<li class="level1"><a href="#serving-controls">服务控制</a></li>
<li class="level2"><a href="#typical-compile-time-problems">典型的编译时问题</a></li>
<li class="level2"><a href="#distributing-qaxserver-binaries">分发QAxServer的二进制文件</a></li>
<li class="level1"><a href="#using-the-controls">控件使用</a></li>
<li class="level2"><a href="#supported-and-unsupported-activex-clients">支持和不支持的ActiveX客户端</a></li>
<li class="level2"><a href="#typical-runtime-errors">典型的运行时问题</a></li>
<li class="level2"><a href="#debugging-runtime-errors">运行时错误调试</a></li>
<li class="level1"><a href="#class-information-and-tuning">类信息与更新</a></li>
<li class="level2"><a href="#developing-licensed-components">开发受许可组件</a></li>
<li class="level2"><a href="#more-interfaces">更多接口</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">在Qt中构建ActiveX服务器</h1>
<span class="subtitle"></span>
<!-- $$$activeqt-server.html-description -->
<div class="descr"> <a name="details"></a>
<p><a href="qaxserver-module.html">QAxServer</a>是<a href="activeqt-index.html">ActiveQt</a>框架的一部分.它包含三个类:</p>
<ul>
<li><a href="qaxfactory.html">QAxFactory</a>被定义用来创建COM对象</li>
<li><a href="qaxbindable.html">QAxBindable</a>提供一个Qt窗体和COM对象间接口.</li>
<li><a href="qaxaggregated.html">QAxAggregated</a>可以被子类化以实现额外的COM接口.</li>
</ul>
<p>提供了一些关于ActiveX控件和COM对象实现的<a href="../qtdoc/examples-activeqt.html">示例</a></p>
<p>详细描述:</p>
<a name="using-the-library"></a>
<h2 id="using-the-library">库的使用</h2>
<p>将标准的其他应用程序转变为COM服务器使用了<a href="qaxserver-module.html">QAxServer</a>库，必须将<code>axserver</code>添加到<code>.pro</code>文件的QT变量中.</p>
<p>一个跨进程的可执行服务器是从如下<code>.pro</code>文件生成的:</p>
<pre class="cpp">

  TEMPLATE = app
  QT  += axserver

  RC_FILE  = qaxserver.rc
  ...

</pre>
<p>构建一个进程内的COM服务器则像下边这样编辑<code>.pro</code>文件:</p>
<pre class="cpp">

  TEMPLATE = lib
  QT += axserver
  CONFIG  += dll

  DEF_FILE = qaxserver.def
  RC_FILE  = qaxserver.rc
  ...

</pre>
<p><code>qaxserver.rc</code>和<code>qaxserver.def</code>文件是框架的一部分，可以引用它们的常用位置(在<code>.pro</code>文件中设置路径),或者直接将它们拷贝到项目目录.你可以修改这些只要是作为类型库入口而被包含的任何文件.例如你可以添加版本信息,或者指定一个不同的工具箱图标.</p>
<p>使用<code>axserver</code>模块将会使<code>qmake</code>工具向构建系统添加一些所需的构建步骤:</p>
<ul>
<li>二进制文件需要链接到<code>qaxserver.lib</code>而不是<code>qtmain.lib</code></li>
<li>使用<a href="../qtdoc/activeqt-idc.html">idc</a>工具来为COM服务器生成IDL文件</li>
<li>使用MIDL工具将IDL编译成一个类型库(编译安装的一部分)</li>
<li>将生成的类型库作为二进制资源添加到服务器的二进制文件中(依然使用<a href="../qtdoc/activeqt-idc.html">idc</a>工具)</li>
<li>注册服务器</li>
</ul>
<p>为了跳过后处理步骤,还要进行<code>qaxserver_no_postlink</code>设置.</p>
<p>另外可以使用<code>VERSION</code>变量指定版本号,例如:</p>
<pre class="cpp">

  TEMPLATE = lib
  VERSION = 2.5
  ...

</pre>
<p>在注册时被指定的版本号还将作为类型库和服务器的版本号.</p>
<a name="out-of-process-vs-in-process"></a>
<h3 >跨进程与进程内</h3>
<p>COM服务器到底是作为一个独立的可执行程序还是一个共享库主要取决于在服务器中所提供的COM对象的类型.</p>
<p>一个可执行的服务器程序优于一个独立的应用程序但是增加了COM客户端与COM对象间的通信开销.如果一个控件出现编程错误,那么运行了该控件的服务器端将会崩溃而客户端可以能够继续运行.不是所有的COM客户端都支持可运行的服务端程序.</p>
<p>进程内服务器通常更小,启动时间也更快.客户端和服务器之间的通信是通过虚拟函数调用直接完成的,并且没有引入远程过程调用所增加的开销. 然而,如果服务端崩溃,那么客户端程序也会崩溃,而且并不是所有功能都适用进程内服务器 (例如无法再COM的运行对象表(ROT)中注册.</p>
<p>这两种服务器都可以使用Qt作为共享库或者静态的链接到服务器的二进制文件中.</p>
<a name="typical-errors-during-the-post-build-steps"></a>
<h3 >Post-Build步骤中的典型错误</h3>
<p>为使<a href="activeqt-index.html">ActiveQt</a>的特定的post-processing步骤对服务器有效必须满足一下要求:</p>
<ul>
<li>所有的控件可以通过唯一实例<a href="../qtwidgets/qapplication.html">QApplication</a>来创建</li>
<li>服务器的初始链接包括一个临时的类型库资源.</li>
<li>运行服务器所需的所有以来项都存在与系统路径中(或者在调用环境所使用的的路径内.提示:Visual Studio需要单独地对它的环境变量在Tools|Options|Directories对话框中进行设置).</li>
</ul>
<p>如果这些要求有一个或多个没有满足,可能会出现如下错误:</p>
<a name="the-server-executable-crashes"></a>
<h4 >The Server Executable Crashes</h4>
<p>为了生成IDL,widgets作为控件导出需要被实例化(构造函数已经被调用).这时只存在一个<a href="../qtwidgets/qapplication.html">QApplication</a>对象.widget构造函数不能附在任何其他没有被创建的对象上,以防止指向空指针</p>
<p>可以运行-dumpidl outputfile进行调试以检查哪里发生了崩溃.</p>
<p>注意,没有控件的函数被调用.</p>
<a name="the-server-executable-is-not-a-valid-win32-application"></a>
<h4 >The Server Executable Is Not a Valid Win32 Application</h4>
<p>添加的类型库损坏了服务器的二进制文件.这是一个windows下的bug发生在进行release版本构建时.</p>
<p>在链接的第一步需要将一个虚拟(dummy)的类型库链接到可执行文件它会在之后被idc替换.可以像示例一样在项目文件中加入一个带有类型库的资源文件.</p>
<a name="unable-to-locate-dll"></a>
<h4 >&quot;Unable to locate DLL&quot;</h4>
<p>构建系统需要运行服务器可执行文件来生成接口定义,并注册服务器.如果动态链接库不在服务器所连接的路径中,那么会失败.(例如:Visual Studio调用服务器时在环境设置的&quot;Directories&quot;选项中设置).必须确保所有服务器所需的的动态链接库和插件都位于错误消息框打印的路径中(也可参看 <a href="../qtdoc/windows-deployment.html#the-windows-deployment-tool">The Windows Deployment Tool</a>).</p>
<a name="cannot-open-file"></a>
<h4 >&quot;Cannot open file ..&#x2e;&quot;</h4>
<p>当最后一个客户端停止使用它时,ActiveX服务器无法正常关闭.通常应用关闭时需要等待两秒,但也可以通过任务管理器杀死该进程.(当客户端不正确释放控件时).</p>
<a name="the-control-cannot-be-instantiated"></a>
<h4 >The Control Cannot be Instantiated</h4>
<p>如果是这样,则需使用管理员权限为服务器注册.</p>
<a name="implementing-controls"></a>
<h2 id="implementing-controls">控件实现</h2>
<p>使用Qt实现一个COM对象,会创建一个或会有任意一个<a href="../qtcore/qobject.html">QObject</a>的子类.如果这个类是<a href="../qtwidgets/qwidget.html">QWidget</a>的子类,那么这个COM对象就会是ActiveX控件.</p>
<pre class="cpp">

  <span class="preprocessor">#include &lt;QWidget&gt;</span>

  <span class="keyword">class</span> MyActiveX : <span class="keyword">public</span> <span class="type">QWidget</span>
  {
      Q_OBJECT

</pre>
<p><a href="../qtcore/qobject.html#Q_OBJECT">Q_OBJECT</a>宏被用来为<a href="activeqt-index.html">ActiveQt</a>框架提供关于widget的元对象信息</p>
<pre class="cpp">

  Q_CLASSINFO(<span class="string">&quot;ClassID&quot;</span><span class="operator">,</span> <span class="string">&quot;{1D9928BD-4453-4bdd-903D-E525ED17FDE5}&quot;</span>)
  Q_CLASSINFO(<span class="string">&quot;InterfaceID&quot;</span><span class="operator">,</span> <span class="string">&quot;{99F6860E-2C5A-42ec-87F2-43396F4BE389}&quot;</span>)
  Q_CLASSINFO(<span class="string">&quot;EventsID&quot;</span><span class="operator">,</span> <span class="string">&quot;{0A3E9F27-E4F1-45bb-9E47-63099BCCD0E3}&quot;</span>)

</pre>
<p>使用<a href="../qtcore/qobject.html#Q_CLASSINFO">Q_CLASSINFO</a>()宏用来为COM对象指定标识符. <code>ClassID</code>和<code>InterfaceID</code>是必须的,而<code>EventsID</code>在对象有信号时才必须被使用.这些标识符可以通过系统工具<code>uuidgen</code> or <code>guidgen</code>生成.</p>
<p>可以为你的每个类指定额外的属性,详情可以参看<a href="activeqt-server.html#class-information-and-tuning">类信息和更新</a>.</p>
<pre class="cpp">

  Q_PROPERTY(<span class="type">int</span> value READ value WRITE setValue)

</pre>
<p>使用<a href="../qtcore/qobject.html#Q_PROPERTY">Q_PROPERTY</a>()宏为ActiveX控件声明属性.</p>
<p>像任何y <a href="../qtcore/qobject.html">QObject</a>子类一样声明了一个继承自父对象的构造函数,功能,信号,槽. </p>
<!-- <p>If a standard constructor is not present the compiler will issue an error &quot;no overloaded function takes 2 parameters&quot; when using the default factory through the <a href="qaxfactory.html#QAXFACTORY_DEFAULT">QAXFACTORY_DEFAULT</a>() macro. If you cannot provide a standard constructor you must implement a <a href="qaxfactory.html">QAxFactory</a> custom factory and call the constructor you have in your implementation of <a href="qaxfactory.html#createObject">QAxFactory::createObject</a>.</p>
--><pre class="cpp">

  <span class="keyword">public</span>:
      MyActiveX(<span class="type">QWidget</span> <span class="operator">*</span>parent <span class="operator">=</span> <span class="number">0</span>)
      <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

      <span class="type">int</span> value() <span class="keyword">const</span>;

  <span class="keyword">public</span> <span class="keyword">slots</span>:
      <span class="type">void</span> setValue(<span class="type">int</span> v);
      <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

  <span class="keyword">signals</span>:
      <span class="type">void</span> valueChange(<span class="type">int</span> v);
      <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

  };

</pre>
<p><a href="activeqt-index.html">ActiveQt</a>框架会导出属性,公有槽,信号作为ActiveX的属性,方法,事件.并将Qt的数据类型转换为等同的COM数据类型.</p>
<a name="data-types"></a>
<h3 >数据类型</h3>
<p>Qt与COM属性转换对照:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Qt data type</th><th >COM property</th></tr></thead>
<tr valign="top" class="odd"><td >bool</td><td >VARIANT_BOOL</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qstring.html">QString</a></td><td >BSTR</td></tr>
<tr valign="top" class="odd"><td >int</td><td >int</td></tr>
<tr valign="top" class="even"><td >uint</td><td >unsigned int</td></tr>
<tr valign="top" class="odd"><td >double</td><td >double</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qtglobal.html#qlonglong-typedef">qlonglong</a></td><td >CY</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qtglobal.html#qulonglong-typedef">qulonglong</a></td><td >CY</td></tr>
<tr valign="top" class="even"><td ><a href="../qtgui/qcolor.html">QColor</a></td><td >OLE_COLOR</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qdate.html">QDate</a></td><td >DATE</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qdatetime.html">QDateTime</a></td><td >DATE</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qtime.html">QTime</a></td><td >DATE</td></tr>
<tr valign="top" class="even"><td ><a href="../qtgui/qfont.html">QFont</a></td><td >IFontDisp*</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtgui/qpixmap.html">QPixmap</a></td><td >IPictureDisp* <!-- <p>COM cannot marshal IPictureDisp across process boundaries, so <a href="../qtgui/qpixmap.html">QPixmap</a> properties cannot be called for out-of-process servers. You can however marshal the image data via e.g&#x2e; temporary files. See the Microsoft <a href="http://support.microsoft.com/default.aspx?scid=kb;[LN];Q150034">KB article Q150034</a> for more information.</p>
--></td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qvariant.html">QVariant</a></td><td >VARIANT</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qvariant.html#QVariantList-typedef">QVariantList</a> (same as <a href="../qtcore/qlist.html">QList</a>&lt;<a href="../qtcore/qvariant.html">QVariant</a>&gt;)</td><td >SAFEARRAY(VARIANT)</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qstringlist.html">QStringList</a></td><td >SAFEARRAY(BSTR)</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qbytearray.html">QByteArray</a></td><td >SAFEARRAY(BYTE)</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qrect.html">QRect</a></td><td >User defined type</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qsize.html">QSize</a></td><td >User defined type</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qpoint.html">QPoint</a></td><td >User defined type</td></tr>
</table></div>
<p>在信号槽中作为参数时的数据类型转换对照:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Qt data type</th><th >COM parameter</th></tr></thead>
<tr valign="top" class="odd"><td >bool</td><td >[in] VARIANT_BOOL</td></tr>
<tr valign="top" class="even"><td >bool&amp;</td><td >[in, out] VARIANT_BOOL*</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qstring.html">QString</a>, const <a href="../qtcore/qstring.html">QString</a>&amp;</td><td >[in] BSTR</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qstring.html">QString</a>&amp;</td><td >[in, out] BSTR*</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qstring.html">QString</a>&amp;</td><td >[in, out] BSTR*</td></tr>
<tr valign="top" class="even"><td >int</td><td >[in] int</td></tr>
<tr valign="top" class="odd"><td >int&amp;</td><td >[in,out] int</td></tr>
<tr valign="top" class="even"><td >uint</td><td >[in] unsigned int</td></tr>
<tr valign="top" class="odd"><td >uint&amp;</td><td >[in, out] unsigned int*</td></tr>
<tr valign="top" class="even"><td >double</td><td >[in] double</td></tr>
<tr valign="top" class="odd"><td >double&amp;</td><td >[in, out] double*</td></tr>
<tr valign="top" class="even"><td ><a href="../qtgui/qcolor.html">QColor</a>, const <a href="../qtgui/qcolor.html">QColor</a>&amp;</td><td >[in] OLE_COLOR</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtgui/qcolor.html">QColor</a>&amp;</td><td >[in, out] OLE_COLOR*</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qdate.html">QDate</a>, const <a href="../qtcore/qdate.html">QDate</a>&amp;</td><td >[in] DATE</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qdate.html">QDate</a>&amp;</td><td >[in, out] DATE*</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qdatetime.html">QDateTime</a>, const <a href="../qtcore/qdatetime.html">QDateTime</a>&amp;</td><td >[in] DATE</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qdatetime.html">QDateTime</a>&amp;</td><td >[in, out] DATE*</td></tr>
<tr valign="top" class="even"><td ><a href="../qtgui/qfont.html">QFont</a>, const <a href="../qtgui/qfont.html">QFont</a>&amp;</td><td >[in] IFontDisp*</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtgui/qfont.html">QFont</a>&amp;</td><td >[in, out] IFontDisp**</td></tr>
<tr valign="top" class="even"><td ><a href="../qtgui/qpixmap.html">QPixmap</a>, const <a href="../qtgui/qpixmap.html">QPixmap</a>&amp;</td><td >[in] IPictureDisp*</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtgui/qpixmap.html">QPixmap</a>&amp;</td><td >[in, out] IPictureDisp**</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qlist.html">QList</a>&lt;<a href="../qtcore/qvariant.html">QVariant</a>&gt;, const <a href="../qtcore/qlist.html">QList</a>&lt;<a href="../qtcore/qvariant.html">QVariant</a>&gt;&amp;</td><td >[in] SAFEARRAY(VARIANT)</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qlist.html">QList</a>&lt;<a href="../qtcore/qvariant.html">QVariant</a>&gt;&amp;</td><td >[in, out] SAFEARRAY(VARIANT)*</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qstringlist.html">QStringList</a>, const <a href="../qtcore/qstringlist.html">QStringList</a>&amp;</td><td >[in] SAFEARRAY(BSTR)</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qstringlist.html">QStringList</a>&amp;</td><td >[in, out] SAFEARRAY(BSTR)*</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qbytearray.html">QByteArray</a>, const <a href="../qtcore/qbytearray.html">QByteArray</a>&amp;</td><td >[in] SAFEARRAY(BYTE)</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qbytearray.html">QByteArray</a>&amp;</td><td >[in, out] SAFEARRAY(BYTE)*</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qobject.html">QObject</a>*</td><td >[in] IDispatch*</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qrect.html">QRect</a>&amp; <!-- <p>OLE needs to marshal user defined types by reference (ByRef), and cannot marshal them by value (ByVal). This is why const-references and object parameters are not supported for <a href="../qtcore/qrect.html">QRect</a>, <a href="../qtcore/qsize.html">QSize</a> and <a href="../qtcore/qpoint.html">QPoint</a>.</p>
--></td><td >[in, out] struct <a href="../qtcore/qrect.html">QRect</a> (user defined)</td></tr>
<tr valign="top" class="even"><td ><a href="../qtcore/qsize.html">QSize</a>&amp;</td><td >[in, out] struct <a href="../qtcore/qsize.html">QSize</a> (user defined)</td></tr>
<tr valign="top" class="odd"><td ><a href="../qtcore/qpoint.html">QPoint</a>&amp;</td><td >[in, out] struct <a href="../qtcore/qpoint.html">QPoint</a> (user defined)</td></tr>
</table></div>
<p>enums and flags也可以被导出(参看Q_ENUMS()和Q_FLAGS()).作为参数传入的数据类型与作为返回值情况一致.</p>
<p>任何以其他数据类型的属性,信号/槽都将被<a href="activeqt-index.html">ActiveQt</a>框架忽略.</p>
<a name="sub-objects"></a>
<h3 >子对象</h3>
<p>COM对象有多个子对象,每个子对象代表一个COM对象的子元素. 当一个多文档扩展表应用程序作为一个COM对象时,这个应用程序可以为每一张扩展表提供一个子对象.</p>
<p>任何<a href="../qtcore/qobject.html">QObject</a>子类都可以作为ActiveX子对象的类型而被使用,只要它在<a href="qaxfactory.html">QAxFactory</a>是已知的.然后这个类型就可以作为属性或信号/槽的参数类型或者是返回值的数据类型.</p>
<a name="property-notification"></a>
<h3 >属性通知</h3>
<p>采用了多继承,从<a href="qaxbindable.html">QAxBindable</a>类钟继成,以使得属性能够被客户端绑定:</p>
<pre class="cpp">

  <span class="preprocessor">#include &lt;QAxBindable&gt;</span>
  <span class="preprocessor">#include &lt;QWidget&gt;</span>

  <span class="keyword">class</span> MyActiveX : <span class="keyword">public</span> <span class="type">QWidget</span><span class="operator">,</span> <span class="keyword">public</span> <span class="type">QAxBindable</span>
  {
      Q_OBJECT

</pre>
<p>在实现属性写入函数时,要使用<a href="qaxbindable.html">QAxBindable</a>类的requestPropertyChange()和 propertyChanged()函数来允许ActiveX客户端可以绑定控件属性.</p>
<!-- <p>This is not required, but gives the client more control over the ActiveX control.</p>
--><a name="serving-controls"></a>
<h2 id="serving-controls">服务控制</h2>
<p>为了使COM服务器能够适用COM系统,它必须适用五个字段的唯一标识符在COM系统中注册.这些标识符由<code>guidgen</code>或者<code>uuidgen</code>生成提供.注册信息允许将导出控件的远程过程调用的控件和读取到的控件导出的属性和方法的类型信息排序本地化为二进制文件提供给发出请求的ActiveX控件.</p>
<p>当客户端请求创建一个COM对象时服务器必须导出一个<a href="qaxfactory.html">QAxFactory</a>的实现.使用以下的宏可以轻易实现:</p>
<pre class="cpp">

  QAXFACTORY_BEGIN(<span class="string">&quot;{ad90301a-849e-4e8b-9a91-0a6dc5f6461f}&quot;</span><span class="operator">,</span>
                   <span class="string">&quot;{a8f21901-7ff7-4f6a-b939-789620c03d83}&quot;</span>)
      QAXCLASS(MyWidget)
      QAXCLASS(MyWidget2)
      QAXTYPE(MySubType)
  QAXFACTORY_END()

</pre>
<p><code>MyWidget</code>和<code>MyWidget2</code>将作为COM对象导出,可以在客户端上被创建,并注册为<code>MySubType</code>类型在<code>MyWidget</code>和<code>MyWidget2</code>的属性和参数中使用.</p>
<p><a href="qaxfactory.html">QAxFactory类文档</a>解释了如何使用和实现这个宏以及在第三方factory上的使用.</p>
<p>对于跨进程的可执行服务器可以实现一个main()函数,在main()函数中实例化一个<a href="../qtwidgets/qapplication.html">QApplication</a>对象,然后进入事件循环,就像一个平常的Qt应用程序一样.在默认情况下应用程序会被作为一个标准的Q他应用程序被启动,但如果在命令行中传递了<code>-activex</code> 参数将会作为一个ActiveX服务器而被启动.使用<a href="qaxfactory.html#isServer">QAxFactory::isServer</a>()判断来创建和运行一个标准应用程序界面否则就退出:</p>
<pre class="cpp">

  <span class="preprocessor">#include &lt;QApplication&gt;</span>
  <span class="preprocessor">#include &lt;QAxFactory&gt;</span>

  <span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span>argv<span class="operator">[</span><span class="operator">]</span>)
  {
      <span class="type">QApplication</span> app(argc<span class="operator">,</span> argv);
      <span class="keyword">if</span> (<span class="operator">!</span><span class="type">QAxFactory</span><span class="operator">::</span>isServer()) {
          <span class="comment">// create and show main window</span>
      }
      <span class="keyword">return</span> app<span class="operator">.</span>exec();
  }

</pre>
<p><a href="activeqt-index.html">ActiveQt</a>提供了提供了一个main函数的默认实现. 默认实现中调用<a href="qaxfactory.html#startServer">QAxFactory::startServer</a>(),创建一个<a href="../qtwidgets/qapplication.html">QApplication</a>实例然后调用exec().</p>
<p>构建ActiveX服务器可执行性程序先运行<code>qmake</code>生成makefile,然后像其他Qt应用程序一样使用与编译器匹配的make工具.make程序需要在命令行中带上<code>-regserver</code>选项向系统注册表注册控件,最终生成可执行文件.</p>
<p>如果ActiveX服务器时一个可执行程序一下则会支持以下的命令行选项:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >选项</th><th >结果</th></tr></thead>
<tr valign="top" class="odd"><td ><code>-regserver</code></td><td >把服务器注册到系统注册表</td></tr>
<tr valign="top" class="even"><td ><code>-unregserver</code></td><td >将服务器从系统注册表中去除</td></tr>
<tr valign="top" class="odd"><td ><code>-activex</code></td><td >将应用程序作为一个ActiveX服务器启动</td></tr>
<tr valign="top" class="even"><td ><code>-dumpidl &lt;file&gt; -version x.y</code></td><td >将服务器的IDL写入到特定文件. 类型库的版本会被设置为x.y</td></tr>
</table></div>
<p>在所有的Windows系统中,进程内服务器可以使用<code>regsvr32</code>工具注册.</p>
<a name="typical-compile-time-problems"></a>
<h3 >典型的编译时问题</h3>
<p>以下列出的编译或连接错误是基于Microsoft Visual C++ 6.0编译器发布的错误.</p>
<a name="no-overloaded-function-takes-2-parameters"></a>
<h4 >&quot;No overloaded function takes 2 parameters&quot;</h4>
<p>当错误发生在代码使用的<a href="qaxfactory.html#QAXFACTORY_DEFAULT">QAXFACTORY_DEFAULT</a>()宏时,而widget类没有构造函数供默认的factory使用.添加一个标准的widget构造函数或者实现一个不需要widget类有构造函数的自定义factory都是可行的.</p>
<p>当错误位置发生在使用的<a href="qaxfactory.html#QAXFACTORY_EXPORT">QAXFACTORY_EXPORT</a>()宏时,是因为<a href="qaxfactory.html">QAxFactory</a>子类没有合适的构造函数.可以为factory类提供一个如下的公有类构造函数</p>
<pre class="cpp">

  MyFactory(<span class="keyword">const</span> <span class="type">QUuid</span> <span class="operator">&amp;</span><span class="operator">,</span> <span class="keyword">const</span> <span class="type">QUuid</span> <span class="operator">&amp;</span>);

</pre>
<a name="syntax-error-bad-suffix-on-number"></a>
<h4 >&quot;Syntax error: bad suffix on number&quot;</h4>
<p>唯一标识符没有作为字符串传入宏<a href="qaxfactory.html#QAXFACTORY_EXPORT">QAXFACTORY_EXPORT</a>()或<a href="qaxfactory.html#QAXFACTORY_DEFAULT">QAXFACTORY_DEFAULT</a>().</p>
<a name="unresolved-external-symbol-ucm-instantiate"></a>
<h4 >&quot;Unresolved external symbol _ucm_instantiate&quot;</h4>
<p>服务器不能导出<a href="qaxfactory.html">QAxFactory</a>的实现.在项目的实现文件中的其中一个使用<a href="qaxfactory.html#QAXFACTORY_EXPORT">QAXFACTORY_EXPORT</a>()宏去实例化和导出factory,或者使用<a href="qaxfactory.html#QAXFACTORY_DEFAULT">QAXFACTORY_DEFAULT</a>()宏来使用一个默认的factory.</p>
<a name="ucm-initialize-already-defined-in"></a>
<h4 >&quot;_ucm_initialize already defined in ..&#x2e;&quot;</h4>
<p>服务器导出来不止一个<a href="qaxfactory.html">QAxFactory</a>的实现,或者导出一个相同的实现两次.如果使用了默认factory,<a href="qaxfactory.html#QAXFACTORY_DEFAULT">QAXFACTORY_DEFAULT</a>()宏项目文件中只能被使用一次.使如果服务器提供多个ActiveX控件那么请使用一个自定义的<a href="qaxfactory.html">QAxFactory</a>实现和宏<a href="qaxfactory.html#QAXFACTORY_EXPORT">QAXFACTORY_EXPORT</a>()</p>
<a name="distributing-qaxserver-binaries"></a>
<h3 >分发QAxServer的二进制文件</h3>
<p>用Qt写的ActiveX服务器可以使用Qt作为共享库,也可以将他静态链接到二进制文件中.两种方法都将产生一个相当大的包(要么是服务器的二进制文件包本身变得很大,要么就是必须发送Qt DLL).</p>
<a name="installing-stand-alone-servers"></a>
<h4 >安装一个独立运行的服务器</h4>
<p>当ActiveX服务器也可以作为一个独立运行的应用程序时,在目标系统安装上可执行文件后,需要在命令行中带上<code>-regserver</code>参数,使作为服务器运行.然后服务器提供的控件就可以用于ActiveX客户端.</p>
<a name="installing-in-process-servers"></a>
<h4 >安装程序内服务器</h4>
<p>当ActiveX服务器是安装包的一部分时,使用Microsoft提供的<code>regsvr32</code>工具在目标系统中注册控件.如果这个工具不存在可以加载这个DLL到安装程序中,解析<code>DllRegisterServer</code>符号并调用函数:</p>
<pre class="cpp">

  HMODULE dll <span class="operator">=</span> LoadLibrary(<span class="string">&quot;myserver.dll&quot;</span>);
  <span class="keyword">typedef</span> HRESULT(__stdcall <span class="operator">*</span>DllRegisterServerProc)();
  DllRegisterServerProc DllRegisterServer <span class="operator">=</span>
      (DllRegisterServerProc)GetProcAddress(dll<span class="operator">,</span> <span class="string">&quot;DllRegisterServer&quot;</span>);

  HRESULT res <span class="operator">=</span> E_FAIL;
  <span class="keyword">if</span> (DllRegisterServer)
      res <span class="operator">=</span> DllRegisterServer();
  <span class="keyword">if</span> (res <span class="operator">!</span><span class="operator">=</span> S_OK)
      <span class="comment">// error handling</span>

</pre>
<a name="distributing-servers-over-the-internet"></a>
<h4 >在互谅网上分发服务器</h4>
<p>如果想在网页上使用服务器中的控件,需要使服务器可用于该浏览器的网页浏览,并且需要在网页中指定服务器包的位置.</p>
<p>要指定服务器位置需要使用网站OBJECT的CODEBASE属性.属性值可以指向服务器文件本身,或指向一个INF文件(INF会列出服务器需要的其他文件例如Qt DLL),或者指向一个压缩了的CAB归档文件.</p>
<p>INF和CAB文件几乎每一个都会被记录:</p>
<pre class="cpp">

  [version]
      signature=&quot;$CHICAGO$&quot;
      AdvancedINF=2.0
   [Add.Code]
      simpleax.exe=simpleax.exe
   [simpleax.exe]
      file-win32-x86=thiscab
      clsid={DF16845C-92CD-4AAB-A982-EB9840E74669}
      RegisterServer=yes

</pre>
<p>来自Microsoft的CABARC可以轻易的生成一个CAB归档文件:</p>
<pre class="cpp">

  cabarc N simpleax<span class="operator">.</span>cab simpleax<span class="operator">.</span>exe simple<span class="operator">.</span>inf

</pre>
<p>INF文件是假定静态构建的,所以所使用的的其他DLL依赖关系没有列出.要为依赖DLL的ActiveX服务器做分发,必须添加依赖项并向库文件提供归档文件.</p>
<a name="using-the-controls"></a>
<h2 id="using-the-controls">控件使用</h2>
<p>ActiveX控件使用,比如将它们嵌入网页需要使用<code>&lt;object&gt;</code> HTML标签.</p>
<pre class="cpp">

  <span class="operator">&lt;</span>object ID<span class="operator">=</span><span class="string">&quot;MyActiveX1&quot;</span> CLASSID<span class="operator">=</span><span class="string">&quot;CLSID:ad90301a-849e-4e8b-9a91-0a6dc5f6461f&quot;</span><span class="operator">&gt;</span>
     <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
  <span class="operator">&lt;</span>\object<span class="operator">&gt;</span>

</pre>
<p>初始化控件属性,可以这样:</p>
<pre class="cpp">

  <span class="operator">&lt;</span>object ID<span class="operator">=</span><span class="operator">.</span><span class="operator">.</span><span class="operator">.</span><span class="operator">&gt;</span>
      <span class="operator">&lt;</span>param name<span class="operator">=</span><span class="string">&quot;name&quot;</span> value<span class="operator">=</span><span class="string">&quot;value&quot;</span><span class="operator">&gt;</span>
  <span class="operator">&lt;</span>\object<span class="operator">&gt;</span>

</pre>
<p>如果浏览器支持脚本使用,ActiveX还支持使用JavaScript, VBScript和表单来编写控件.<a href="../qtdoc/examples-activeqt.html">ActiveQt示例</a>包含了在网页中使用示例控件.</p>
<a name="supported-and-unsupported-activex-clients"></a>
<h3 >支持和不支持的ActiveX客户端</h3>
<p>下面是基于我们自己的ActiveX控件和客户端应用程序的经验,并不是完全的.</p>
<a name="supported-clients"></a>
<h4 >支持的客户端</h4>
<p>这些应用程序使用的ActiveX控件都使用<a href="activeqt-index.html">ActiveQt</a>开发.但值得注意的是一些客户端只支持进程内控件</p>
<ul>
<li>Internet Explorer</li>
<li>Microsoft ActiveX Control Test Container</li>
<li>Microsoft Visual Studio 6.0</li>
<li>Microsoft Visual Studio.NET/2003</li>
<li>Microsoft Visual Basic 6.0</li>
<li>MFC- and ATL-based containers</li>
<li>Sybase PowerBuilder</li>
<li><a href="activeqt-index.html">ActiveQt</a> based containers</li>
</ul>
<p>Microsoft Office应用程序是支持的但需要将控件注册为&quot;Insertable&quot;对象. Reimplement <a href="qaxfactory.html#registerClass">QAxFactory::registerClass</a> to add this attribute to the COM class, or set the &quot;Insertable&quot; class info for your class to &quot;yes&quot; using the <a href="../qtcore/qobject.html#Q_CLASSINFO">Q_CLASSINFO</a> macro.</p>
<a name="unsupported-clients"></a>
<h4 >Unsupported Clients</h4>
<p>We have not managed to make <a href="activeqt-index.html">ActiveQt</a> based COM objects work with the following client applications.</p>
<ul>
<li>Borland C++ Builder (Versions 5 and 6)</li>
<li>Borland Delphi</li>
</ul>
<a name="typical-runtime-errors"></a>
<h3 >Typical Runtime Errors</h3>
<a name="the-server-does-not-respond"></a>
<h4 >The Server Does Not Respond</h4>
<p>If the system is unable to start the server (check with the task manager whether the server runs a process), make sure that no DLL the server depends on is missing from the system path (e.g&#x2e; the Qt DLL!). Use a dependency walker to view all dependencies of the server binary.</p>
<p>If the server runs (e.g&#x2e; the task manager lists a process), see the following section for information on debugging your server.</p>
<a name="the-object-cannot-be-created"></a>
<h4 >The Object Cannot Be Created</h4>
<p>If the server could be built and registered correctly during the build process, but the object cannot be initiliazed e.g&#x2e; by the OLE/COM Object Viewer application, make sure that no DLL the server depends on is missing from the system path (e.g&#x2e; the Qt DLL). Use a dependency walker to view all dependencies of the server binary.</p>
<p>If the server runs, see the following section for information on debugging your server.</p>
<a name="debugging-runtime-errors"></a>
<h3 >Debugging Runtime Errors</h3>
<p>To debug an in-process server in Visual Studio, set the server project as the active project, and specify a client &quot;executable for debug session&quot; in the project settings (e.g&#x2e; use the ActiveX Test Container). You can set breakpoints in your code, and also step into <a href="activeqt-index.html">ActiveQt</a> and Qt code if you installed the debug version.</p>
<p>To debug an executable server, run the application in a debugger and start with the command line parameter <code>-activex</code>. Then start your client and create an instance of your ActiveX control. COM will use the existing process for the next client trying to create an ActiveX control.</p>
<a name="class-information-and-tuning"></a>
<h2 id="class-information-and-tuning">Class Information and Tuning</h2>
<p>To provide attributes for each COM class, use the <a href="../qtcore/qobject.html#Q_CLASSINFO">Q_CLASSINFO</a> macro, which is part of Qt's meta object system.</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Key</th><th >Meaning of value</th></tr></thead>
<tr valign="top" class="odd"><td >Version</td><td >The version of the class (1.0 is default)</td></tr>
<tr valign="top" class="even"><td >Description</td><td >A string describing the class.</td></tr>
<tr valign="top" class="odd"><td >ClassID</td><td >The class ID. You must reimplement <a href="qaxfactory.html#classID">QAxFactory::classID</a> if not specified.</td></tr>
<tr valign="top" class="even"><td >InterfaceID</td><td >The interface ID. You must reimplement <a href="qaxfactory.html#interfaceID">QAxFactory::interfaceID</a> if not specified.</td></tr>
<tr valign="top" class="odd"><td >EventsID</td><td >The event interface ID. No signals are exposed as COM events if not specified.</td></tr>
<tr valign="top" class="even"><td >DefaultProperty</td><td >The property specified represents the default property of this class. Ie. the default property of a push button would be &quot;text&quot;.</td></tr>
<tr valign="top" class="odd"><td >DefaultSignal</td><td >The signal specified respresents the default signal of this class. Ie. the default signal of a push button would be &quot;clicked&quot;.</td></tr>
<tr valign="top" class="even"><td >LicenseKey</td><td >Object creation requires the specified license key. The key can be empty to require a licensed machine. By default classes are not licensed. Also see the following section.</td></tr>
<tr valign="top" class="odd"><td >StockEvents</td><td >Objects expose stock events if value is &quot;yes&quot;. See <a href="qaxfactory.html#hasStockEvents">QAxFactory::hasStockEvents</a>()</td></tr>
<tr valign="top" class="even"><td >ToSuperClass</td><td >Objects expose functionality of all super-classes up to and including the class name in value. See <a href="qaxfactory.html#exposeToSuperClass">QAxFactory::exposeToSuperClass</a>()</td></tr>
<tr valign="top" class="odd"><td >Insertable</td><td >If the value is &quot;yes&quot; the class is registered to be &quot;Insertable&quot; and will be listed in OLE 2 containers (ie. Microsoft Office). This attribute is not be set by default.</td></tr>
<tr valign="top" class="even"><td >Aggregatable</td><td >If the value is &quot;no&quot; the class does not support aggregation. By default aggregation is supported.</td></tr>
<tr valign="top" class="odd"><td >Creatable</td><td >If the value is &quot;no&quot; the class cannot be created by the client, and is only available through the API of another class (ie. the class is a sub-type).</td></tr>
<tr valign="top" class="even"><td >RegisterObject</td><td >If the value is &quot;yes&quot; objects of this class are registered with OLE and accessible from the running object table (ie. clients can connect to an already running instance of this class). This attribute is only supported in out-of-process servers.</td></tr>
<tr valign="top" class="odd"><td >MIME</td><td >The object can handle data and files of the format specified in the value. The value has the format mime:extension:description. Multiple formats are separated by a semicolon.</td></tr>
<tr valign="top" class="even"><td >CoClassAlias</td><td >The classname used in the generated IDL and in the registry. This is esp. useful for C++ classes that live in a namespace - by default, <a href="activeqt-index.html">ActiveQt</a> just removes the &quot;::&quot; to make the IDL compile.</td></tr>
<tr valign="top" class="odd"><td >Implemented Categories</td><td >List of comma-separated Category ID (CATID) UUIDs. Generic mechanism for specifying additional container capabilities, in addition to &quot;control&quot;, &quot;insertable&quot; etc. Typical CATIDs include <code>CATID_InternetAware</code> (&quot;{0DE86A58-2BAA-11CF-A229-00AA003D7352}&quot;), <code>CATID_SafeForScripting</code> (&quot;{7DD95801-9882-11CF-9FA9-00AA006C42C4}&quot;) as well as user-defined CATID values.</td></tr>
</table></div>
<p>Note that both keys and values are case sensitive.</p>
<p>The following declares version 2.0 of a class that exposes only its own API, and is available in the &quot;Insert Objects&quot; dialog of Microsoft Office applications.</p>
<pre class="cpp">

  <span class="keyword">class</span> MyActiveX : <span class="keyword">public</span> <span class="type">QWidget</span>
  {
      Q_OBJECT
      Q_CLASSINFO(<span class="string">&quot;Version&quot;</span><span class="operator">,</span> <span class="string">&quot;2.0&quot;</span>)
      Q_CLASSINFO(<span class="string">&quot;ClassID&quot;</span><span class="operator">,</span> <span class="string">&quot;{7a4cffd8-cbcd-4ae9-ae7e-343e1e5710df}&quot;</span>)
      Q_CLASSINFO(<span class="string">&quot;InterfaceID&quot;</span><span class="operator">,</span> <span class="string">&quot;{6fb035bf-8019-48d8-be51-ef05427d8994}&quot;</span>)
      Q_CLASSINFO(<span class="string">&quot;EventsID&quot;</span><span class="operator">,</span> <span class="string">&quot;{c42fffdf-6557-47c9-817a-2da2228bc29c}&quot;</span>)
      Q_CLASSINFO(<span class="string">&quot;Insertable&quot;</span><span class="operator">,</span> <span class="string">&quot;yes&quot;</span>)
      Q_CLASSINFO(<span class="string">&quot;ToSuperClass&quot;</span><span class="operator">,</span> <span class="string">&quot;MyActiveX&quot;</span>)
      Q_PROPERTY(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>)

  <span class="keyword">public</span>:
      MyActiveX(<span class="type">QWidget</span> <span class="operator">*</span>parent <span class="operator">=</span> <span class="number">0</span>);

      <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
  };

</pre>
<a name="developing-licensed-components"></a>
<h3 >Developing Licensed Components</h3>
<p>If you develop components you might want to control who is able to instantiate those components. Since the server binary can be shipped to and registered on any client machine it is possible for anybody to use those components in his own software.</p>
<p>Licensing components can be done using a variety of techniques, e.g&#x2e; the code creating the control can provide a license key, or the machine on which the control is supposed to run needs to be licensed.</p>
<p>To mark a Qt class as licensed specify a &quot;LicenseKey&quot; using the <a href="../qtcore/qobject.html#Q_CLASSINFO">Q_CLASSINFO</a>() macro.</p>
<pre class="cpp">

  <span class="keyword">class</span> MyLicensedControl : <span class="keyword">public</span> <span class="type">QWidget</span>
  {
      Q_OBJECT
      Q_CLASSINFO(<span class="string">&quot;LicenseKey&quot;</span><span class="operator">,</span> <span class="string">&quot;&lt;key string&gt;&quot;</span>)
      <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
  };

</pre>
<p>The key is required to be able to create an instance of <code>MyLicensedControl</code> on a machine that is not licensed itself. The licensed developer can now redistributes the server binary with his application, which creates the control using the value of &quot;LicenseKey&quot;, while users of the application cannot create the control without the license key.</p>
<p>If a single license key for the control is not sufficient (ie. you want differnet developers to receive different license keys) you can specify an empty key to indicate that the control requires a license, and reimplement <a href="qaxfactory.html#validateLicenseKey">QAxFactory::validateLicenseKey</a>() to verify that a license exists on the system (ie. through a license file).</p>
<a name="more-interfaces"></a>
<h3 >More Interfaces</h3>
<p>ActiveX controls provided by <a href="activeqt-index.html">ActiveQt</a> servers support a minimal set of COM interfaces to implement the OLE specifications. When the ActiveX class inherits from the <a href="qaxbindable.html">QAxBindable</a> class it can also implement additional COM interfaces.</p>
<p>Create a new subclass of <a href="qaxaggregated.html">QAxAggregated</a> and use multiple inheritance to subclass additional COM interface classes.</p>
<pre class="cpp">

  <span class="keyword">class</span> AxImpl : <span class="keyword">public</span> <span class="type">QAxAggregated</span><span class="operator">,</span> <span class="keyword">public</span> ISomeCOMInterface
  {
  <span class="keyword">public</span>:
      AxImpl() {}

      <span class="type">long</span> queryInterface(<span class="keyword">const</span> <span class="type">QUuid</span> <span class="operator">&amp;</span>iid<span class="operator">,</span> <span class="type">void</span> <span class="operator">*</span><span class="operator">*</span>iface);

      <span class="comment">// IUnknown</span>
      QAXAGG_IUNKNOWN

      <span class="comment">// ISomeCOMInterface</span>
      <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
  }

</pre>
<p>Reimplement the <a href="qaxaggregated.html#queryInterface">QAxAggregated::queryInterface</a>() function to support the additional COM interfaces.</p>
<pre class="cpp">

  <span class="type">long</span> AxImpl<span class="operator">::</span>queryInterface(<span class="keyword">const</span> <span class="type">QUuid</span> <span class="operator">&amp;</span>iid<span class="operator">,</span> <span class="type">void</span> <span class="operator">*</span><span class="operator">*</span>iface)
  {
      <span class="operator">*</span>iface <span class="operator">=</span> <span class="number">0</span>;
      <span class="keyword">if</span> (iid <span class="operator">=</span><span class="operator">=</span> IID_ISomeCOMInterface)
          <span class="operator">*</span>iface <span class="operator">=</span> (ISomeCOMInterface <span class="operator">*</span>)<span class="keyword">this</span>;
      <span class="keyword">else</span>
          <span class="keyword">return</span> E_NOINTERFACE;

      AddRef();
      <span class="keyword">return</span> S_OK;
  }

</pre>
<p>Since <code>ISomeCOMInterface</code> is a subclass of <code>IUnknown</code> you will have to implement the <code>QueryInterface()</code>, <code>AddRef()</code>, and <code>Release()</code> functions. Use the QAXAGG_IUNKNOWN macro in your class definition to do that. If you implement the <code>IUnknown</code> functions manually, delegate the calls to the interface pointer returned by the <a href="qaxaggregated.html#controllingUnknown">QAxAggregated::controllingUnknown</a>() function, e.g&#x2e;</p>
<pre class="cpp">

  HRESULT AxImpl<span class="operator">::</span>QueryInterface(REFIID iid<span class="operator">,</span> <span class="type">void</span> <span class="operator">*</span><span class="operator">*</span>iface)
  {
      <span class="keyword">return</span> controllingUnknown()<span class="operator">-</span><span class="operator">&gt;</span>QueryInterface(iid<span class="operator">,</span> iface);
  }

</pre>
<p>Do not support the <code>IUnknown</code> interface itself in your <a href="qaxaggregated.html#queryInterface">queryInterface()</a> implementation.</p>
<p>Implement the methods of the COM interfaces, and use <a href="qaxaggregated.html#object">QAxAggregated::object</a>() if you need to make calls to the <a href="../qtcore/qobject.html">QObject</a> subclass implementing the control.</p>
<p>In your <a href="qaxbindable.html">QAxBindable</a> subclass, implement <a href="qaxbindable.html#createAggregate">QAxBindable::createAggregate</a>() to return a new object of the <a href="qaxaggregated.html">QAxAggregated</a> subclass.</p>
<pre class="cpp">

  <span class="keyword">class</span> MyActiveX : <span class="keyword">public</span> <span class="type">QWidget</span><span class="operator">,</span> <span class="keyword">public</span> <span class="type">QAxBindable</span>
  {
      Q_OBJECT

  <span class="keyword">public</span>:
      MyActiveX(<span class="type">QWidget</span> <span class="operator">*</span>parent);

      <span class="type">QAxAggregated</span> <span class="operator">*</span>createAggregate()
      {
          <span class="keyword">return</span> <span class="keyword">new</span> AxImpl();
      }
  };

</pre>
</div>
<p><b>也可参看</b><a href="activeqt-index.html">ActiveQt Framework</a>.</p>
<!-- @@@activeqt-server.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2017 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
